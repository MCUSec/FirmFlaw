import logging 
import argparse 

# ESP Xtensa Lib Adoptation
def read_tags(tags):
    '''
    read function name from tags
    tags: generated by ctag 
    '''
    funcs_ = set()
    with open(tags, 'r') as file:
        tags = file.readlines()
    for line in tags:
        names = line.split('\t')
        if names[-2] == 'f':
            funcs_.add(names[0])
    return funcs_

def read_symbol(sym_file):
    '''
    read function name from symbol file 
    symbol_file: generated from library using objdump 
    '''
    funcs_ = set()
    with open(sym_file, 'r') as file:
        lines = file.readlines()
    for line in lines:
        if ' F ' in line: # is functions
            funcs_.add(line.split()[-1])
    return funcs_

# The ESP LIB Match
esp_funcdb = {
'esp-phy': read_symbol('./tags/esp-phy-lib.symbol'),
'esp-lwip': read_tags('./tags/esp-lwip.tags'),
'esp-mqtt': read_tags('./tags/esp-mqtt.tags'),
'esp-wifi': read_symbol('./tags/esp32-wifi-lib.symbol'),
'esp-openthread': read_tags('./tags/esp-openthread.tags') | read_symbol('./tags/esp-thread-lib.symbol'),
'esp-mbedtls': read_tags('./tags/mbetls.tags'),
'esp-bt': read_symbol('./tags/esp32-bt-lib.symbol'),
'esp-hal': read_tags('./tags/esp-idf-hal.tags'),
'esp-freertos': read_tags('./tags/freertos-tags'),
}


def count(type, program, lib_match):
    '''
    count the number of match type by program and store it to lib_match
    '''
    if lib_match.get(type) is None:
        lib_match[type] = {}
    if lib_match[type].get(program) is None:
        lib_match[type][program] = 1
    else:
        lib_match[type][program] += 1

def collect(type, program, match, lib_match):
    '''
    seperate the match by type 
    '''
    if lib_match.get(type) is None:
        lib_match[type] = {}
    if lib_match[type].get(program) is None:
        lib_match[type][program] = [match]
    else:
        lib_match[type][program].append(match)

def match_program(match_res, funcdb_map):
    '''
    calculate the match from match result json file 
    '''
    import json
    lib_match = {} # match number 
    lib_match_full = {}
    program_match = set()
    with open(match_res, 'r') as f:
        data = json.load(f)
    for (program, v) in data.items():
        program_match = set()
        for (func, match) in v.items():
            for (t, db_) in funcdb_map.items():
                # bt
                # functionID result 
                if isinstance(match, list):
                    if match[0][0] in db_:
                        # test
                        if match[0][0] in progam_match:
                            print(f'find {match[0][0]} in {program}')
                        program_match.add(match[0][0])
                        # test end
                        count(t, program, lib_match)
                        collect(t, program, {func: match}, lib_match_full)
                # SimMatch result 
                elif match['name'] in db_:
                    count(t, program, lib_match)
                    collect(t, program, {func: match}, lib_match_full)
    return (lib_match, lib_match_full)

def main(args):
    


if __name__ == "__main__":
    parser = argparse.ArgumentParser("Generate the Result from file")
    parser.add_argument("match_result",type=Path,helper="JSON based result from functionID or SimMatch")
    parser.add_argument("threshold",default=2,helper="the threshold of match times to generate library adoption")
    args = parser.parse_args()
    # log
    LOG_FORMAT = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
    DATE_FORMAT = "%m/%d/%Y %H:%M:%S"
    logging.basicConfig(filename=f'./logs/ResGen_{log_time}.log', level=logging.DEBUG, format=LOG_FORMAT, datefmt=DATE_FORMAT)
    try:
        main(args)
    except KeyboardInterrupt:
        logging.error("Exit with keyboard")
        project.close() 